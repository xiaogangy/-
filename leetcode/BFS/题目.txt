1. 二叉树的最小高度
思路：
方法1：深度优先遍历（回溯/递归）。二叉树的最小高度 = min(左子树的最小高度，右子树的最小高度) + 1。即求出每条路径的长度，然后选择最小的路径
方法2：广度优先遍历（队列）。不断往队列中加入节点，弹出节点，当弹出的节点是一个叶子节点时，即为找到了最短路径，返回当前进行的步数。

2. 解开密码锁的最少次数（leetcode 752）
题目：你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。
每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。
思路：如果穷举我们会怎么做？我们每次转动密码锁的一位，每个位置有2个选择，总共有4个波轮，则每次可以有8个选择。进行完一个选择后，下次又有8个选择，我们会发现这其实就是一个8叉树。
求最少操作次数，则就是求多叉树的最小高度。
注意点：要有visited数组，来防止转动波轮的时候，转动到已经转过的数值。

