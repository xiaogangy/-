## 基础
1. 二叉树前、中、后序遍历递归 && 非递归版本
2. 二叉树的层序遍历
3. 写递归算法的关键是明确这个递归函数的定义，也就是说它是干什么的，然后相信这个定义，不要跳入递归中。在二叉树算法中，也就是先搞清楚当前root节点改干什么，然后根据函数定义递归调用子节点。

## 复习题目
### 1. 二叉树的最大路径和  
***题目***：给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

***关键点***：题目中的最大路径和，可以拆分为左子树最大路径 + 根节点的值 + 右子树的最大路径

***思路***：以当前节点做为根节点，寻找从当前节点出发的，达到叶子节点的最大路径和（单侧）；然后再每轮递归的尾部，更新当前的max值；

### 2. 恢复二叉搜索树  
***题目***： 二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

***关键点***：二叉搜索树的特点是左节点 < 根节点 < 右节点

***思路***：根据BST的特点，由于两个节点交换了，通过中序遍历得到的序列里，必然有两个节点的位置是不对的。不对的定义是：这个节点不满足大于左节点且小于右节点的特点。

### 3. 反转二叉树（leetcode 226.）
***题目***：输入一个二叉树根节点root，把整棵树镜像反转。

***思路***：抽象出来就是先把当前节点的左右子节点交换，然后再对左右子树分别进行反转。递归的出口是空节点null。

### 4. 填充每个节点的下一个右侧节点指针（leetcode 116.）
***题目***：给定一棵完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树中有一个指针next指向下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置null。请填充所有节点的next节点。
***思路***：
- 方法1. BFS，使用广度优先遍历，可以在队列中保存当前层级的所有节点，然后再对每个节点添加next指针
- 方法2：递归。不能简单的抽象成将root节点的左节点指向右节点，因为这样的话，两棵树中左树的右节点和右树的左节点就断开了。如果没法解决问题，可以增加函数参数，我们可以抽象为将相邻的两棵树连接起来，传两个数的节点。参考代码如下
```js
function connectTwoNode(node1, node2) {
    if (!node1 || !node2) {
        return;
    }
    // 先把根节点连起来
    node1.next = node2;

    // 递归进行如下
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接两个相邻节点
    connectTwoNode(node1.right, node2.left);
}

```

### 5. 二叉树展开为链表（leetcode 114.）
***题目***：给定一棵二叉树，原地将它展开为一个单链表。这道题看图好理解，直接去看leetcode原题吧。

***思路***：

1. 将root节点的左子树和右子树拉平。
2. 将root的右子树接到左子树下方，然后将整个左子树作为右子树
3. 你问具体每个树是怎么拉平的？递归啊，我不知道！只要给出口就行了，出口就是空节点了。

### 6. 构造最大二叉树（leetcode 654.）
***题目***：给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

***思路***：做二叉树的题目，先分析root节点应该怎么做，然后再分析子节点应该怎么做，就够了，不要试图跳入递归，容易把自己绕晕。   
- 显然应该先找到数组中的最大值，用这个值构造一个节点。
- 数组最大值的左边和右边分别调用递归，构造左右子树。
- 根节点的左节点指向左子树，右节点指向右子树，这也说明这个递归函数要返回根节点。
- 递归的出口：自然就是遇到了一个空数组

### 7. 根据前序遍历和中序遍历构造二叉树
### 8. 根据后序遍历和中序遍历构造二叉树
上面两个题目剑指offer中都有，就不再赘述了


### 9. 寻找重复的子树
***题目***：给定一棵二叉树，返回所有的子树。对于同一类的子树，你只需要返回其中任意一棵的根节点即可。两棵树重复是指他们具有相同的结构以及相同的节点值。

***思路***：
看到这道题目需要思考两个问题：  
1. 如何描述一棵树的结构？
2. 如何知道一棵树的结构？

对于问题1，我们可以考虑使用序列化的方式来表示树，也就是空节点用个特殊值表示，其余节点用数值表示。但是序列化有前中后三种方法，用哪个呢？   
对于问题2，其实就是要遍历一下这棵树。这里我们使用后序遍历，也就是知道了左右子树后自然也就知道这棵树的结构，自然地，序列化也用后续遍历就可以了。

***参考代码***
```js
    var findDuplicateSubtrees = function(root) {
        if (!root) {
            return [];
        }
        const hashMap = {};
        const result = [];
        var findRepeatSubTree = function(root) {
            if (!root) {
                return '#';
            }
            // 序列化左右子树
            const left = findRepeatSubTree(root.left);
            const right = findRepeatSubTree(root.right);
            // 序列化结果
            const struct = left + ','  + right + ',' + root.val;
            if (hashMap[struct] === 1) {
                hashMap[struct]++;
                result.push(root);
            } else {
                hashMap[struct] = hashMap[struct] ?  hashMap[struct] + 1: 1;
            }
            return struct;
        }
        findRepeatSubTree(root)

        return result;
    };
```

### 最近公共祖先（LeetCode 236.）
***题目***：给定一个二叉树，找到该树中两个指定节点的最近公共祖先。两个节点记为P和Q

***思路***：
1. 方法1：当初在剑指offer上看到这道题，自己的思路也是想着，先找到两个节点所在的路径，然后求两条路径最后相同的节点，这种方法可以归为回溯，因为是为了寻找指定节点所在的路径。

2. 方法2：递归。这个递归很有意思，我们知道写递归函数，最重要的就是明确这个递归函数是干什么的，下面我们一点点来梳理一下：

- 先想象一下P和Q的最近公共祖先是什么样子。有两种情况，一种就是P和Q分别在两课树里，那么最近公共组件就肯定在它俩的上方，也就是说P和Q一个在祖先节点的左子树中，一个在祖先节点的右子树中。还有一种情况，就是P或者Q，直接就是二者的最近公共祖先，也就是说一个节点位于另外一个节点的子树中。
- 如果我们有一个函数，在执行到某个节点node时候，可以知道P或者Q在不在它的子树中，是不是就好办一些？比如说，当前节点为X，我知道P和Q都在我的子树中，那么起码X是一个祖先节点（不保证是最近祖先节点）。
- 那么如何才能保证这个祖先节点是最近的祖先节点呢？二叉树的题目逃不过三大遍历，如果我们使用后序遍历，也就是说先访问完了左右子树，再访问当前节点，是不是就能保证是最近的祖先节点了呢。
- 按照如上的定义，那么我这个递归函数需要返回一个boolean值，也就是说表示当前P或者Q在不在这个子树中。但是按照题目的意思，我们需要返回一个节点啊，这个不慌，我们可以在抽象的递归函数中修改一个全局变量，最后把这个全局变量返回回去就行。所以现在这个函数逐渐清晰了：**定义一个函数，函数参数为root，P和Q，函数会判断P或者Q在不在以root为根的树中，返回true或者false。同时，在递归中还会修改一个全局变量，这个全局变量就是在递归函数外层声明的最近公共祖先节点。**
- 参考伪代码为：
    ```js
    var lowestCommonAncestor = function(root, p, q) {
        if (!root) {
            return null;
        }
        var result = null;
        var firstMeetNode = null;
        var coreFunction = function (root, p, q) {
            if (root === null) {
                return false;
            }
            if (root === p || root === q) {
                firstMeetNode = root;
                return true;
            }
            const left = coreFunction(root.left, p, q);
            const right = coreFunction(root.right, p, q);

            if (left && right && !result) {
                result = root;
            }

            return left || right;
        }
        coreFunction(root, p, q);
        return result || firstMeetNode;
    };
    ```

3. 方法3：和上面的方法类似，只不过这个函数定义的不太一样，但是一开始我确实没法把这个递归函数的真实意义想象出来，不过看了上面的分析，理解这个也不太困难了。
- 递归函数的目的：如果P和Q都在当前节点的树中，返回P和Q的最近公共祖先；如果二者都不在树中，返回null；如果二者只有一个节点在当前这棵树中，则返回这个节点，例如只有P在树中，那么返回值就是P。
- 遍历的顺序，仍然是后序遍历  
上面函数的意义，同时也说明了递归的出口，其实这个函数的思路和上面的非常像，只不过是返回值不太一样，可以结合上面的分析和最近公共祖先节点出现的位置，思考一下，也能理解。
- 参考代码
    ```java
    TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // base case
        if (root == null) return null;
        if (root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 情况 1
        if (left != null && right != null) {
            return root;
        }
        // 情况 2
        if (left == null && right == null) {
            return null;
        }
        // 情况 3
        return left == null ? right : left;
    }
    ```