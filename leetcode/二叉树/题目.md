## 基础
1. 二叉树前、中、后序遍历递归 && 非递归版本
2. 二叉树的层序遍历
3. 写递归算法的关键是明确这个递归函数的定义，也就是说它是干什么的，然后相信这个定义，不要跳入递归中。在二叉树算法中，也就是先搞清楚当前root节点改干什么，然后根据函数定义递归调用子节点。

## 复习题目
### 1. 二叉树的最大路径和  
***题目***：给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

***关键点***：题目中的最大路径和，可以拆分为左子树最大路径 + 根节点的值 + 右子树的最大路径

***思路***：以当前节点做为根节点，寻找从当前节点出发的，达到叶子节点的最大路径和（单侧）；然后再每轮递归的尾部，更新当前的max值；

### 2. 恢复二叉搜索树  
***题目***： 二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

***关键点***：二叉搜索树的特点是左节点 < 根节点 < 右节点

***思路***：根据BST的特点，由于两个节点交换了，通过中序遍历得到的序列里，必然有两个节点的位置是不对的。不对的定义是：这个节点不满足大于左节点且小于右节点的特点。

### 3. 反转二叉树（leetcode 226.）
***题目***：输入一个二叉树根节点root，把整棵树镜像反转。

***思路***：抽象出来就是先把当前节点的左右子节点交换，然后再对左右子树分别进行反转。递归的出口是空节点null。

### 4. 填充每个节点的下一个右侧节点指针（leetcode 116.）
***题目***：给定一棵完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树中有一个指针next指向下一个右侧节点。如果找不到下一个右侧节点，则将next指针设置null。请填充所有节点的next节点。
***思路***：
- 方法1. BFS，使用广度优先遍历，可以在队列中保存当前层级的所有节点，然后再对每个节点添加next指针
- 方法2：递归。不能简单的抽象成将root节点的左节点指向右节点，因为这样的话，两棵树中左树的右节点和右树的左节点就断开了。如果没法解决问题，可以增加函数参数，我们可以抽象为将相邻的两棵树连接起来，传两个数的节点。参考代码如下
```js
function connectTwoNode(node1, node2) {
    if (!node1 || !node2) {
        return;
    }
    // 先把根节点连起来
    node1.next = node2;

    // 递归进行如下
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // 连接两个相邻节点
    connectTwoNode(node1.right, node2.left);
}

```

### 5. 二叉树展开为链表（leetcode 114.）
***题目***：给定一棵二叉树，原地将它展开为一个单链表。这道题看图好理解，直接去看leetcode原题吧。

***思路***：

1. 将root节点的左子树和右子树拉平。
2. 将root的右子树接到左子树下方，然后将整个左子树作为右子树
3. 你问具体每个树是怎么拉平的？递归啊，我不知道！只要给出口就行了，出口就是空节点了。

### 6. 构造最大二叉树（leetcode 654.）
***题目***：给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

***思路***：做二叉树的题目，先分析root节点应该怎么做，然后再分析子节点应该怎么做，就够了，不要试图跳入递归，容易把自己绕晕。   
- 显然应该先找到数组中的最大值，用这个值构造一个节点。
- 数组最大值的左边和右边分别调用递归，构造左右子树。
- 根节点的左节点指向左子树，右节点指向右子树，这也说明这个递归函数要返回根节点。
- 递归的出口：自然就是遇到了一个空数组

### 7. 根据前序遍历和中序遍历构造二叉树
### 8. 根据后序遍历和中序遍历构造二叉树
上面两个题目剑指offer中都有，就不再赘述了


### 9. 寻找重复的子树