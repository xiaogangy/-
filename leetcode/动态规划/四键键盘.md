### 四键键盘
***题目***：
![题目](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6413dee2c83f74205c7f2d5eb0784232429512de.png?alt=media)

***思路***：
- 方法1. 很显然这是个穷举的问题，我们可以DP来剪枝。关于状态的定义，我们可以选择{当前剩余的按键数、当前屏幕上的A数量(a_num)、当前缓冲区内的A数量(copy)}来表示当前局面。选择的话，我们每次可以有四种按键选择，状态转移方程就呼之欲出了：

        dp(n, a_num, copy)表示当前剩余按键次数为n，屏幕显示个数为a_num，缓冲区个数copy时，屏幕最终能显示到的A数量。

        做选择：
        dp(n - 1, a_num + 1, copy),    # A
        解释：按下 A 键，屏幕上加一个字符
        同时消耗 1 个操作数

        dp(n - 1, a_num + copy, copy), # C-V
        解释：按下 C-V 粘贴，剪切板中的字符加入屏幕
        同时消耗 1 个操作数

        dp(n - 2, a_num, a_num)        # C-A C-C
        解释：全选和复制必然是联合使用的，
        剪切板中 A 的数量变为屏幕上 A 的数量
        同时消耗 2 个操作数

        base case:
        当n为0时，显然就是屏幕有多少个A就是最终有多少个A，即dp(0, a_num, copy) = a_num;
        而我们要求的目标值是dp(n, 0, 0)，因为这里是定义的dp方程，加上备忘录进行剪枝就可以了。

    缺点：空间复杂度太大了，会超时。因为在计算过程中，会计算很多例如C-A, C-C, C-A, C-C的序列，这些序列显然是不可能成为最优解的。  
    接下来我们就思考一种新的状态定义来解决这个问题。

- 方法2：我们这次只定义一个状态，就剩余的敲击次数n。选择呢，依然是那4个选择，但是取得最多的A依赖于这样一个事实：
    - 要么一直按A：A,A,A,A,……,A(当N比较小时)
    - 要么是另外一个形式：A,A,……,A,C-A,C-C,C-V,C-V,……,C-V, C-A,C-C,C-V,C-V,……,C-V

    因为字符数量少（N 比较小）时，C-A C-C C-V 这一套操作的代价相对比较高，可能不如一个个按 A；而当 N 比较大时，后期 C-V 的收获肯定很大。这种情况下整个操作序列大致是：开头连按几个 A，然后 C-A C-C 组合再接若干 C-V，然后再 C-A C-C 接着若干 C-V，循环下去。

    换句话说，最后一次按键要么是A要么是C-V。

    参考代码：
    ```java
    public int maxA(int N) {
        int[] dp = new int[N + 1];
        dp[0] = 0;
        for (int i = 1; i <= N; i++) {
            // 选择1：按 A 键
            dp[i] = dp[i - 1] + 1;
            // 选择2：按 C-V，那么在哪里开始按C-V呢？我们不得而知，我们需要穷举所有可能按C-V的位置，也就是下面这个for循环了
            // 其中j表示最后一次C-C结束的位置，因为从那一次按键之后，我们就要开始按C-V了
            for (int j = 2; j < i; j++) {
                // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
                // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
                dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
            }
        }
        // N 次按键之后最多有几个 A？
        return dp[N];
    }
    ```