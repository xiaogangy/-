## 什么是回文？
回文串就是正着读和反着读都一样的字符串。

解决此类问题的核心是***双指针***

## 解决子序列问题的常见思路
1. 一维DP数组：表示在子数组array[0……i]中，以array[i]结尾的目标子序列的长度是DP[i]。比如求最长递增子序列。
2. 二维DP数组：  
2.1) 涉及两个字符串/数组时（比如最长公共子序列），DP数组的含义如下：DP[i][j]表示在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。   
2.2) 只涉及一个字符串/数组时（比如本文要讲的最长回文子序列），dp 数组的含义如下：在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。


### 1. 最长回文子串
***题目***：给定一个字符串S，找到S中最长的回文子串。你可以假设S的最长长度为10000。

***思路***：寻找回文串的核心思想：从中间开始向两边扩散来判断回文串。但是回文字符串有可能是奇数的长度，也可能是偶数，所以为了在一个函数里来寻找以当前节点为中心的最长回文串，可以参考如下代码：
```js
// 回文串有奇有偶，所以串两个索引进去
function palindrome(str, l, r) {
    const length = str.length;
    while (l >= 0 && r < length && str[l] === str[r]) {
        l--;
        r++;
    }
    return str.subStr(l + 1, r - l - 1);
}
```
遍历原始字符串，然后每次用如上的函数去搜寻以当前字符作为中心的最长回文子串，就可以得到结果。

时间复杂度为O(N^2)，空间复杂度为O(1)；


### 2. 最长回文子序列
***题目***：给定一个字符串s，找到其中最长的回文子序列。可以假设s的最长长度为1000。返回最长回文子序列的长度。

***思路***：按照如上说的处理子序列的常见思路，可以考虑构造二维DP数组。

***核心***：
- 状态：字符串的左右区间[i, j];
- DP数组的含义：在区间[i, j]中，最长回文子序列的长度为DP[i][j]。
- base case：i = j时，显然DP[i][j] = 1

***状态转移方程***：  

在上面的分析中，我们知道最终求得问题是DP[0][str.length - 1]，显然是从base case开始计算后续的区间。考虑我们现在正在计算DP[i][j]，如果str[i] = str[j]，显然我们只需要计算出DP[i + 1][j - 1]的值，然后再加2即可。如果str[i] != str[j]，由于二者不同，所以肯定不会同时出现在最长的回文子序列里，所以只需要计算DP[i+1][j]和DP[i][j-1]中的最大值即可。整理一下，状态转移方程如下：

    dp[i][j] = dp[i+1][j-1] + 2, str[i] === str[j];
    dp[i][j] = max(dp[i+1][j], dp[i][j-1]), str[i] != str[j];

### 3. 判断回文链表
***题目***：输入一个单链表的头结点，判断这个链表中节点值值是不是回文。

***思路***：
1. **数组**：最简单粗暴的办法就是遍历一遍链表，然后把链表的值放到数组中，然后使用双指针的思路，判断当前值是不是回文。这种思路的空间复杂度为O(N)，因为需要借助一个数组。
2. **递归**：一个神奇的思路！想一想上面数组的方法中，我们在数组的首尾各设置一个指针，然后逐项比较。那么在链表中，可不可以借助这种思路呢？答案是可以的。试想我们用递归的方法遍历输出链表的所有元素，参考代码如下：
    ```js
    function traverse(head) {
        if (head === null) {return;}
        // 先打印后面的节点
        traverse(head.next);
        // 再打印头结点
        console.log(head.val);
    }
    ```
    考虑递归的出口，我们会在进行到链表最后一个节点时候，开始返回，打印最后一个节点，然后依次是倒数第二个，倒数第三个……。这不就是双指针的尾指针吗？借助一个全局变量标识头指针，我们就可以完成双指针的操作：
    ```java
    // 左侧指针
    ListNode left;

    boolean isPalindrome(ListNode head) {
        left = head;
        return traverse(head);
    }

    boolean traverse(ListNode right) {
        if (right == null) return true;
        boolean res = traverse(right.next);
        // 后序遍历代码
        res = res && (right.val == left.val);
        left = left.next;
        return res;
    }
    ```
    当然，递归造成的结果，空间复杂度也是O(N)。
3. **反转链表**：如果链表是一个回文链表会怎样？我们只需要把链表的后半部分反转一下，然后比较前半部分和后半部分就可以了。反转链表不用说，那么如何找到链表的中点呢？当然就是我们的快慢指针了，一个走1步，一个走2步！但是这里要注意，如果链表是奇数个节点，那么当快指针指向最后一个节点的时候，此时慢指针刚好指向链表中间。而如果是偶数个节点呢？函数结束时，快指针指向了一个空节点，而慢指针刚好指向后半段的起点。注意区分这两种情况。

### 4. 构造回文的最小插入次数
***题目***：输入一个字符串 s，你可以在字符串的任意位置插入任意字符。如果要把 s 变成回文串，请你计算最少要进行多少次插入？

***思路***：问题规模变小会是什么样的？显然就是字符串变短了，按照如上的套路，我们可以考虑用二维dp数组来解决这道题。

***核心***：
- 状态：区间[i, j]，或者说在[i, j]区间的字符串
- dp数组含义：dp[i][j]表示将区间[i, j]内的字符串变成回文字符串最少需要的插入次数，那么结果就是求dp[0][last]
- base case: 显然当i === j时，dp[i][j] = 0, 而j < i的区间，根本就不合法，直接设置为-1就可以了，其实也用不到。

***状态转移方程***：
当str[i] === str[j]的时候，求dp[i][j]只需要我们求出内层字符串最少需要多少次插入才能变为回文字符串就可以了。   
当str[i] !== str[j]呢？一种直观的做法就是在dp[i+1][j-1]的基础上加2就可以把外层字符串也变成一个回文字符串，但是这个结果一定能保证进行的插入次数就是最小的吗？那不一定。我们需要反向思考一下，因为这个时候左右两个字符不相同，那么最后肯定是需要插入一个值把某一侧的值变成另外一侧相同的值吧，那么此时str[i+1, j]或者str[i, j-1]一定是一个回文字符串了。所以，把[i, j]变成回文字符串的，只需要把[i+1, j]或者[i, j-1]变成回文子串，然后再添加一个字符就好了。这不，状态就缩小了吗？完整的状态转移方程如下：

    dp[i][j] = dp[i+1][j-1], 当str[i] === str[j];
    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1, 当str[i] != str[j];