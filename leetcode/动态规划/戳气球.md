## 戳气球问题

***题目***：
有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

***思路***：
- 方法1：首先这道题有个最直观的方法，那就是穷举，或者说回溯。我们可以穷举气球被戳破的顺序，然后计算最终的结果，然后找到这些所有可能里的最大值。显然这就是一个全排列的问题，用回溯法的套路就可以解决。但是回溯的解决，必然时间复杂度非常高，可以考虑用DP来解决

- 方法2：动态规划。看了那么多的模板，我们直觉上就觉得可以定义一个二维DP数组 **dp[i][j]** 来表示出破[i, j]之间的气球，所能得到的硬币的最大数量。但是气球要最后全部戳完啊，如果区间[i, j]为闭区间的话，最后到底是戳i呢还是戳j呢？所以为了简化这个问题，我们可以扩展一下这个题目。我们假设这一排气球的左右两边分别有一个虚拟的气球，他们其中的硬币为1，然后把问题抽象为：在一排气球points中，请你戳破气球0和气球n+1之间的所有气球（不包括0和n+1），使得最终只剩下气球0和气球n+1两个气球，最多能够得到多少分？现在dp[i][j]表示的区间变为开区间了，这样就好解决了。

    状态转移方程怎么找呢？如果我们正向做选择，也就是先戳破哪个气球，然后再戳破哪个气球，这就又变成回溯法了。我们不妨换个思路，来考虑最后戳破的气球是哪一个。假设最后戳破的气球索引为k，那么状态转移方程就是：

        dp[i][j] = dp[i][k] + dp[k][j] + nums[k] * nums[i] * nums[j]，其中 i < k < j

    这里写代码的时候，注意几个要点：
    - dp数组由于加入了左右两个虚拟气球，声明长度的时候应该为 nums.length + 2
    - 再穷举状态的时候，这道题是i和j，我们经常不知道遍历的顺序是怎样。这里有个技巧，我们通过base case 和 终点来确定，也就是说要沿着base case向终点逼近。所以这道题画个二维矩阵，你就会发现是用自下而上，从左往右的顺序来遍历i和j。

