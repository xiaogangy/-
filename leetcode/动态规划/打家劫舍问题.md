## 打家劫舍I (leetcode 198.)
***问题***：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

***核心：***  
- 状态：可以偷得屋子，不妨用i表示从第i号屋子开始偷起，i表示当前房子的索引
- DP数组含义：DP[i]表示可选的屋子从第i个屋子开始，可以偷到的最大值
- base case：当i大于等于所有屋子的长度时，可以偷得金额为0
- 状态转移方程：  
    DP[i] = max(不偷当前的屋子：DP[i + 1], 偷当前的屋子：DP[i + 2] + prices[i])

## 打家劫舍II (leetcode 213.)
***问题***：输入依然是一个数组，但是现在房子绕成了一圈，也就是说这一排房子的首尾是相连的，如果偷了第一个房子，显然最后一个房子就不能偷；如果偷了最后一个，显然第一个房子也不能偷；

***关键点***：其实就是在上一题的基础上，加了一个可偷房屋的区间范围。现在房子有了首尾不能一起偷的限制，我们只需要尝试一下[0, n-2] 和 [1, n-1]这两个区间可偷取的最大值，就是想要的结果。状态转移方程什么的都没变，只是函数上加了一个start和end限制可偷取的范围区间。

## 打家劫舍III（leetcode 337.）
***问题***：在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

***核心***：
- 状态：根节点，也就是说以当前节点为根节点的树，都是可以偷的范围
- DP函数含义：DP(root)表示可选的屋子从root这个屋子开始，可以偷到的最大值
- base case：当然是叶子节点或者空节点了，空节点就是0，叶子节点就是当前的值
- 状态转移方程：

    DP(root) = max(   
        偷当前节点：DP(root.left.right) + DP(root.left.right) + DP(root.right.left) + DP(root.right.right),  
        不偷当前节点：DP(root.left) + DP(root.right)      
    )