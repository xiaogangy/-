## 股票问题基础
***问题***：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润，你最多可以完成K笔交易。  
注意：你不能在买入股票前卖出股票。

***核心***：   
- **状态**：即用哪些值可以完整的描述一次问题，并且随着问题规模的变化，这些值也相应的变化。这道题的状态有三个：

    - 天数
    - 允许交易的最大次数
    - 当前股票的持有状态（1表示持有，0表示没有持有）

- ***DP数组***：DP[i][k][0|1]，今天是第i天结束，允许最多k次交易，此时手上持有or没有股票，所能获得的最大利润。  
显然，我们想求的答案就是DP[n][k][0]，因为最后一天结束，手上没有股票的利润肯定大于此时持有股票的利润。
- **base case**：持有状态就不用考虑了，总共就两种，我们考虑一下天数和交易次数的特殊值；对天数和交易次数而言，0都是一个特殊值；

    - DP[0][K][0] = 0; DP[0][K][1] = -infinity  
        当前是第0天结束，手上没有持有股票，给定最多K次交易，能获得的最大利润是0；当前是第0天结束，手上持有股票，给定最多K次交易，能获得的最大利润是-infinity；
    - DP[i][0][0] = 0; DP[i][0][1] = -infinity   
        当前是第i天结束，最多只能交易0次，此时手上没有持有股票，则获得的最大利润是0；同理，如果此时手上持有股票，是不可能发生的，记为-infinity；
- ***状态转移方程***：

        DP[i][k][0] = max(DP[i-1][k][0], DP[i-1][k][1] + prices[i])
        解释：第i天结束时，我没有持有股票，可以从两种状态过来
        - 昨天就没有持有股票，然后今天也没买
        - 昨天持有股票，然后今天卖了

        DP[i][k][1] = max(DP[i-1][k][1], DP[i-1][k-1][0] - prices[i])
        解释：第i天结束时，我持有股票，可以从两种状态过来
        - 昨天就持有股票，然后我今天没操作
        - 昨天不持有股票，今天买了股票

## 题目实战
### 1. K = 1，最多交易1次
***思路***：这道题在剑指offer中出现过，其实完全不用DP就可以做。常规思路是我们遍历数组时，以这一天的价格作为买入价格，然后再数组剩余部分找最大的价格交易出去，时间复杂度为O(N^2)；我们可以在遍历时，以当前价格作为卖出价格，那么当遍历到第i天时，之前的最小值已经知道了，所以只需要O(N)就可以解决问题。  
方法二：套用这道题的状态转移方程   

        DP[i][1][0] = max(DP[i-1][1][0], DP[i-1][1][1] + prices[i]);
        DP[i][1][1] = max(DP[i-1][1][1], DP[i-1][0][0] - prices[i]) = max(DP[i-1][1][1], -prices[i]);
        我们发现现在状态转移方程中跟K没关系了，直接把K去掉就可以：
        DP[i][0] = max(DP[i-1][0], DP[i-1][1] + prices[i]);
        DP[i][1] = max(DP[i-1][1], -prices[i]);

### 2. K = +infinity，交易次数不限制
***思路***：不限制交易次数，其实就可以用贪心来解决，遍历数组时，每次找一个逆序序列的最后一个元素，作为买入点，然后找到这个元素后的升序序列的最后一个元素进行交易。这样就可以得到最多利润。实现算法时，可以遍历整个price价格列表，策略是所有上涨交易日都买卖（赚的所有利润），所有下降交易日都不买卖（永不亏钱）   
方法二：套用状态转移方程

        DP[i][k][0] = max(DP[i-1][k][0], DP[i-1][k][1] + prices[i]);
        DP[i][k][1] = max(DP[i-1][k][1], DP[i-1][k][0] - prices[i]);
        由于交易次数不限制，那么k值在两次状态中没区别，我们可以认定为k值是不变的，则可变为：
        DP[i][0] = max(DP[i-1][0], DP[i-1][1] + prices[i]);
        DP[i][1] = max(DP[i-1][1], DP[i-1][0] - prices[i]);

### 3. K = +infinity with cooldown，每次sell之后要等一天才能继续交易
***思路***：也比较简单，只要把状态转移方程稍微修改一下就好
***状态转移方程***：

        DP[i][0] = max(DP[i-1][0], DP[i-1][1] + prices[i]);
        DP[i][1] = max(DP[i-1][1], DP[i-2][0] - prices[i]);
        解释：第i天选择买入股票时，要从i-2的状态转移，而不是i-1

### 4. K = +infinity with fee，包含交易费
***思路***：每次交易要手续费，只要把手续费从利润中减去就成。
***状态转移方程***：

        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
        解释：相当于买入股票的价格升高了。
        在第一个式子里减也是一样的，相当于卖出股票的价格减小了。

### 5. K = 2，最多只能交易2次
***思路***：这里K成为了一个正常的数，因此使用原始的状态转移方程来进行状态转化。   
***参考代码***：
```JAVA
        int max_k = 2;
        int[][][] dp = new int[n][max_k + 1][2];
        for (int i = 0; i < n; i++) {
                // 注意：这里正着或者逆着遍历都可以，因为外层的i是从0开始的，而i等于0的时候的结果全是base case
                for (int k = max_k; k >= 1; k--) {
                        if (i - 1 == -1) { /*处理 base case */ }
                        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
                }
        }
        // 穷举了 n × max_k × 2 个状态，正确。
        return dp[n - 1][max_k][0];

        // 由于k值取值范围比较小，可以直接把K等于1和2的情况全部列举出来
        dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
        dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
        dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
        dp[i][1][1] = max(dp[i-1][1][1], -prices[i])

        int maxProfit_k_2(int[] prices) {
        int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
        int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
        for (int price : prices) {
                dp_i20 = Math.max(dp_i20, dp_i21 + price);
                dp_i21 = Math.max(dp_i21, dp_i10 - price);
                dp_i10 = Math.max(dp_i10, dp_i11 + price);
                dp_i11 = Math.max(dp_i11, -price);
        }
        return dp_i20;
        }
```

### 6. K = 任意值
***思路***：这道题和上一题，k = 2其实是没有任何区别的，但是有一个地方是可以优化的。我们知道要穷举k值的所有大小，但是这是没有必要的。一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。
***参考代码***：
```java
int maxProfit_k_any(int max_k, int[] prices) {
    int n = prices.length;
    if (max_k > n / 2) 
        return maxProfit_k_inf(prices);

    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) 
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) { /* 处理 base case */ }
            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
        }
    return dp[n - 1][max_k][0];
}
```