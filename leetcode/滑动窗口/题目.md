### 1. 最小覆盖子串（leetcode 76.）
***题目***：给你一个字符串S，一个字符串T，请在字符串S中找出：包含T所有字母的最小子串。例如：输入为S='ADOBECODEEBANC', T='ABC',  输出为'BANC'。如果S中不存在这样的子串，则返回空字符串''。  
***思路***： 滑动窗口可以用left，right两个指针来表示。right指针先开始不断往右移动，当当前的滑动窗口中包含了所有的字符串字母后，right指针停止滑动，此时开始收缩left指针。left指针也不断向
右滑动，直到滑动窗口中刚好不包含所有T中的字符。
- 如何知道当前窗口中已经包含了所有T中的字符？window是一个哈希表，其中存储了当前窗口里在T中出现的字符和字数，如果刚好所有字符都出现，则right指针要停止了
- 什么时候更新数据？在收缩窗口的时候，在left指针往右移之前，先保存一下当前的长度，然后再更新window，need，valid以及left等数据

### 2. 字符串排列（leetcode 567.）
***题目***：给定两个字符串s1和s2，写一个函数判断s2是否包含s1的排列。  
***步骤***：
1. 将s1中的所有字符填充到need数组中；
2. right指针不断右移，同时更新window中出现的在s1中的字符和个数、
3. 当window.size恰好等于need的长度时，right指针停止滑动，此时要开始滑动left指针了。
4. 先判断当前valid的数量是不是等于need的长度，如果相等，就找到了一个；如果不等，则left指针要向右滑动。  
重复进行步骤2~4。

### 3. 找所有字母异位词（leetcode 438.）
***题目***：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
***思路***：这道题与上面的题基本一致，只是在收缩窗口的时候，得到一个合法的异位词，并不是直接返回true，而是将这个词的起点存到result数组中，然后继续滑动。

### 4. 最长无重复子串（leetcode 3.）
***题目***：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
***思路***：之前剑指offer上就给了滑动窗口和DP两种解法，这里按照labuladong的思路过一下。核心是判断滑动窗口停止的时机，这里的条件是当前window中出现了重复字符，很直观。
***参考代码***
```java
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> window;

    int left = 0, right = 0;
    int res = 0; // 记录结果
    while (right < s.size()) {
        char c = s[right];
        right++;
        // 进行窗口内数据的一系列更新
        window[c]++;
        // 判断左侧窗口是否要收缩
        while (window[c] > 1) {
            char d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            window[d]--;
        }
        // 在这里更新答案
        res = max(res, right - left);
    }
    return res;
}
```