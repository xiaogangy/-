# 如何理解递归？

在解决剑指offer面试题12：矩阵中的路径时，看到解答思路是用递归来解决问题。作者给出的解答是应对回溯问题，一般是用递归来解决，这一块我就很迷糊，再加上递归我就更迷糊了，虽然我第一反应是回溯问题不应该用栈解决吗？这和递归在本质上是一样的，但你上来就跟我说用递归解决，我就蒙圈了，于是乎我就觉得我对递归理解的不透彻，就翻了翻资料，在这里总结一下。

## 递归的定义
维基百科或者课本上解释的都非常简单
>递归算法是一种直接或者间接调用自身函数或者方法的算法。  

……这句话等于没说，我们从函数执行上来理解一下递归的过程。

首先明确函数的嵌套调用这样一个概念，意思就是在一个函数里可以调用另外一个函数。那么程序的底层执行是怎样的呢？比如在main函数中调用sub这个函数，当程序执行到sub这个函数时，计算机会开辟一块新的内存空间，初始化sub这个函数，然后把sub函数的参数传入进去，同时保存当前执行的环境，也就是保存main函数执行到哪儿了，参数是什么样子这一类的信息。然后就开始执行sub函数，sub函数执行完成后，会把cpu的执行权返回给main函数，main函数从之前中断处再开始执行。

那么来看递归，递归其实在计算机层面是完全合理的，我们不应该用人脑思维直观的去看他。举个例子，以斐波那契数列为例，我们知道F(N) = F(N-1) + F(N-2)，简单写个递归的解法：
```JS
1.     function Fibonacci(n) {
2.        if (n === 0) {
3.            return 0;
4.        }
5.        if (n === 1) {
6.            return 1;
7.        }
8.        return Fibonacci(n - 1) + Fibonacci(n - 2);
9.     }
```
当程序执行到第8行的时候，实际上会在内存中开辟一块新的空间，然后把CPU的执行权交给新的这块内存区域内的代码，这样的逻辑不断的重复，那么什么时候会停止呢？如果不能正确停止，就死循环了，程序退出不了了。所以这就是第2-7行的逻辑，当程序执行到这些逻辑时，会返回，这里一返回，那么嵌套调用它的那一个函数就可以继续执行了，同理那个函数也会返回，依次类推，我们就从后又返回了最开始函数。

如果还是不好理解，可以考虑程序执行时候的函数调用栈，其实主函数并没有结束，只是把子函数压入了栈顶，子函数又在执行的过程中又压入了子函数的子函数，这样不断的压入，直到有个子函数它不需要压入了，它可以直接执行完成，然后弹出函数栈的栈顶，开始执行前一个栈顶的函数。这也就是为什么递归问题一般也可以借助栈来实现的原因。

所以本质上来讲，**递归调用和普通函数调用没有区别**

## 递归的特点
- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件，即存在递归出口

这几个特点也刚好是我们在写算法来确定是不是可以用递归来解决问题的依据，展开说一下；

1. 一个问题的解可以分解为几个子问题的解   
子问题就是相对与其前面的问题数据规模更小的问题，比如斐波那契数列中的F(10) = F(9) + F(8)。

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样   
把问题拆分后，求解子问题的思路是一模一样的，比如对F(9)的定义和解法，和F(10)完全一致。

3. 存在递归终止条件，即存在递归出口   
把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。在某个子问题的时候，遇到了终止条件，这个时候子问题的解就找到了，然后就可以一步步返回。

## 写递归的思路
1. 出口条件，即递归“什么时候结束”，这个通常在递归函数的开始就写好;

2. 如何由"情况 n" 变化到"情况 n+1", 也就是非出口情况，也就是一般情况——"正在"递归中的情况；

3. 初始条件，也就是这个递归调用以什么样的初始条件开始；

可以重温一下数学归纳法，递归其实就是对数学归纳法的应用。

## 递归思维
最后，引用一段知乎上的话，觉得说的挺好的：
>如何学习递归？   
>首先是思想方法上要转变，不要试图解决问题(这是常规的思考方式)，而应该“鼠目寸光”地只想解决一点点，要点是，解决一点点之后，剩下来的问题还是原来的问题，但规模要比原问题小了思想和语言是密切相关的，所以问题的提法也很重要。一个问题这样提可能感觉很难写出递归，换种提法，可能就写出来了。平时就要注意用递归的方式思考，譬如什么是链表？以递归来看就是一个指针，指向一个含有链表的指针。一旦你用这种方式看待链表，你会发现写链表的代码非常容易。反之，则非常容易拖泥带水从代码层面看，递归就是函数的循环，所以只要透彻理解函数，写递归代码没什么难的。