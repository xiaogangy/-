/**
 * @description 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。
 * 例如，输入数组[5, 7, 6, 9, 11, 10, 8]，则返回true，因为这个整数序列是下图二叉搜索树的后续遍历结果。如果输入的数组是[7, 4, 6, 5]，则由于没有哪棵
 * 二叉搜索树的后序遍历结构是这个序列，因此返回false。
 *        8
 *      /  \
 *     6   10
 *    / \  / \
 *   5  7 9  11
 *
 * 思路：这道题跟“重建二叉树”那个题目的解决思路非常类似。我们先来明确一些基本知识，二叉搜索树的特征是 左节点 < 根节点 < 右节点。后序遍历的顺序是左节点 -> 右节点 -> 根节点。
 * 从后序遍历的定义中我们可以知道，后序遍历的结果中最后一个值是根节点。那么我们再结合二叉搜索树的特征，左子树的节点都小于根节点值，右子树的节点都大于根节点，我们就可以把输入的
 * 整数数组成两部分。在上面的示例中，8为根节点，左子树的节点为[5, 7, 6]，右子树的节点为[9, 11, 8]。这个时候，我们可以再用同样的规律去判断左右数组是否是一个二叉搜索树，这
 * 就可以用递归实现了。那么递归的终点是什么呢？
 * - 根据按照如上规则划分左右数组后，发现右数组中有值小于根节点，这个是违背二叉搜索树的特性的，返回false
 * - 如果划分出来的左右数组都是空数组，也就是是我们递归进行到最后只剩下一个节点的时候，自然是返回true的。
 * （判断递归的终止条件通常是不容易的，我们在举例进行分析的时候，例如如上例子，我们分析到5和7的时候，就知道左子树已经分析完了。我们怎么知道的呢？我们知道5和7都只是一个节点了，也就是它
 * 作为一个树已经不能再分出来有值的左右子树了，我们思考的时候这种思路不会特别注意，但是写程序的时候，计算机是不知道怎么判断终止的，所以我们需要把这种思路具象化告诉计算机，例如上面例子终止
 * 的判断就是它的左右子树都是空指针了，也就是它本身已经是叶子节点了，而一个节点自然是一个二叉搜索树。如果左右子树只有一个是空指针，另外一个有值呢？空指针的那边我们也认为它是一棵二叉搜索树。）
 */

function verifySquenceOfBST(sequence) {
    // 递归出口
    if (!sequence || !sequence.length) {
        return false;
    }

    const length = sequence.length;
    // 1. 先找到根节点
    const root = sequence[length - 1];

    // 2. 根据左子树小于根节点值的特点，划分左子树的数组
    let i = 0; // i用来保存划分左右子树的index，最终i的值指向右子树数组的起始位置
    for (; i < length - 1; i++) {
        if (sequence[i] > root) {
            break;
        }
    }
    // 判断构成右子树的数组中的所有值，必须都大于根节点的值
    let j = i;
    for (; j < length - 1; j++) {
        if (sequence[j] < root) {
            return false;
        }
    }

    // 3. 拆分左右子树之后，开始递归判断左右子数组是否可以构成二叉搜索树
    let left = true;
    // 如果长度为0，那就说明左子树为空，不用判断了，直接就是true
    if (i > 0) {
        left = verifySquenceOfBST(sequence.slice(0, i));
    }

    let right = true;
    if (i < length - 1) {
        right = verifySquenceOfBST(sequence.slice(i, sequence.length - 1));
    }

    return (left && right);
}