/**
 * @desc 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个正数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。
 * 例如，输入的数组为[1, -2, 3, 10, -4, 7, 2, -5]，最大的子数组为[3, 10, -4, 7, 2]，因此子数组和的最大值为18。
 *
 * solution1: 暴力解法
 * 枚举数组的所有子数组。一个长度为n的数组，总共有n(n+1)/2个子数组。然后再计算每个子数组的和，最快也要o(n^2)的时间。
 *
 * solution2: 找规律
 * 我们以题目中的例子来分析一下，我们开始先将1放入，此时最大值就是1；然后放入-2，此时和变为-1，但是最大值不变，仍然是1；接着遍历到3，因为之前的和是-1，
 * 此时如果把3加上，还不如让3独立出来，这样的话当前和更新为，最大值也是3；再就是10，最大和更新为13；接着我们遇到了-4，加上-4虽然会让当前和变小，但是
 * 无伤大雅，因为后续加起来的数字有可能让整个子数组的和变得更大嘛，所以当前和变为9，最大和还是13；后面继续……当最后数组遍历完，最大和就得到了。
 * 从这个分析我们知道，我们需要遍历数组，还需要保存两个值，一个是当前和currentSum，一个是最大和maxSum。
 *
 * solution3：动态规划
 * DP牛逼！我们用f(i)表示以第i个元素结尾的子数组的最大和，那么我们会得到如下的公式：
 * f(i) = pData[i] 当i = 0或者f(i - 1) <= 0；f(i - 1) + pData[i]，当i != 0并且f(i - 1) > 0；
 * 这个公式也很好理解，如果当以第i-1个数字结尾的子数组中所有数字的和小于0时，以第i个数字结尾的子数组的最大和肯定就是本身；否则就是当前这第i个数字，加上
 * 之前的和。DP的实现和上面的如出一辙，这里就不实现了。
 */

function solution(array) {
    if (!array.length) {
        return null;
    }
    // 遍历到第i个元素时，加上这个元素得到的当前子数组和
    let currentSum = -Infinity;
    // 最大连续子数组和
    let maxSum = -Infinity;
    for (let i = 0; i < array.length; i++) {
        const current = array[i];
        if (currentSum < 0) {
            // 如果之前的子数组和为负数了，currentSum肯定要更新为当前数字
            currentSum = current;
        } else {
            currentSum += current;
        }
        maxSum = currentSum > maxSum ? currentSum : maxSum;
    }
    return maxSum;
}
