/**
 * @desc 给定一个数组A[0,1,……,n-1]，请构建一个数组B[0,1,……,n-1]，其中B中的元素B[i]=A[0]*A[1]*……*A[i-1]*A[i+1]*……*A[n-1]。不能使用除法。
 *
 * solution：B中某个位置i处的元素就是A中移除位置i处元素后剩余所有值的乘积，如果用除法这个就太easy了，我们求得A中所有值的乘积，然后再除以A[i]就可以得到B[i]的值。
 * 如果不能使用除法，最暴力的办法就是每次求一个B[i]，进行n-1次的相乘，时间复杂度是O(N^2)。
 * 优雅的办法：
 * B这个结果模式，可以看成两个两个部分的乘积，第一部分是A[0]*A[1]*……*A[i-1]，第二部分是A[i+1]*……*A[n-1]，也就是我们按照A[i]将乘积分成了两个部分。我们将第一部分记为C[i]，
 * 第二部分记为D[i]。我们来精简一下这个公式：
 * - 当i = 0时，C[i] = 1；当i = n-1时，D[i] = 1;
 * - 其他情况下，C[i] = C[i -1] * A[i - 1]; D[i] = D[i + 1] * A[i + 1];
 * 我们可以先顺序求得C这个数组中的每个元素，然后逆序的开始求解B中的每个元素。
 * talk is cheap, show me the code
 */

/**
 * 构建乘积数组
 * @param {*} A 数组A
 * @return {Array} 返回数组B
 */
function solution(A) {
    // 健壮性: 仅当数组里有元素时，才能计算
    if (!A.length) {
        return [];
    }

    // 注意学习一下这里的思路，既然我们最终是要填充B，构建C和D也需要数组，如何能够有效的利用现有空间呢？
    // 可以在构建B的时候直接就把C的数据填充的到B，就会省掉一个临时数组(C)的空间。
    // 那么有了C之后还需要D吗，其实是不需要的，我们沿着一个数组的方向填充B（下面的写法是倒着填充），变短的那一侧（C）是需要一开始构造一个临时数组的，
    // 另外一侧是长度逐渐变长，只需要保存上一次的元素，然后计算下一次的时候，再乘以一个新的A[i]元素。

    const B = new Array(A.length).fill(0);
    // 1. 先填充C
    for (let i = 0; i < B.length; i++) {
        if (i === 0) {
            // 第一个元素初始化为1
            B[i] = 1;
        } else {
            B[i] = B[i - 1] * A[i - 1];
        }
    }

    // 2. 声明一个变量保存D
    let temp = 1; // 初始化为1，因为填充B的时候是倒着填充的，这里temp = 1表示D[n - 1]的情况
    for (let i = B.length - 2; i >= 0; i--) {
        temp = temp * A[i + 1];
        B[i] = B[i] * temp;
    }

    return B;
}

function testFunc() {
    const A = [1, 2, 3];
    console.log(solution(A));
}
testFunc();