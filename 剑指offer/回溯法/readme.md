## 什么是回溯法？

回溯法是指在解决问题时，先纵深解决，如果行不通，就返回前一步，再尝试另外一种方法。

回溯法可以看成是蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。***回溯法非常适合解决由多个步骤组成的问题，并且每个步骤都有多个选项。*** 当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直至达到最终的状态。


## 分析是否可用回溯法？如何用回溯法解决问题？

可以用回溯法解决的问题，其所有选项可以形象地用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶节点对应着终结状态。如果在叶节点的状态满足题目的约束条件，那么我们找到了一个解决方案。

如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他选项。如果上一个节点所有可能的选项都已经尝试，并且不能达到满足约束条件的终结状态，则再次回溯到上一个节点。如果所有节点的所有选项都已经尝试过，但仍然不能满足约束条件的终结状态，则该问题无解

## 回溯法实例

图的深度优先遍历(DFS)就是最好的例子，我们沿着一条路径一直找到底，没有值了再返回上一层，再纵深下去。
前序、中序、后序遍历都是DFS，通常DFS可以用栈来实现，因为栈可以保存上一次的状态。

## 回溯法的实现
回溯法的两种解决思路：
- ***递归***：由于即使在不同的层级，解决问题的思路仍然完全一致，只是问题规模变得更小，所以我们可以用递归来解决回溯问题。即对大问题，先用同样的方法解决子问题，子问题解决完后，返回到上一层。
- ***栈***：栈可以保存之前的状态，对于回溯来说很方便

## 应用场景
通常物体在二维方格运动这种问题都可以用回溯法解决

## 解题模式-solution pattern
回溯法的代码书写具有对称性。什么意思呢？也就是说一旦进入到递归代码中，我们会先把这一轮递归要做的一些操作先执行，表示我已经访问过了当前节点，并对这些节点进行了预期的操作，例如，将当前节点添加进路径中。然后对子问题或者更小规模的问题，我们进行递归计算，例如对当前节点的上下左右四个节点都进行访问。最后，根据回溯的特性，如果我们在某一次尝试中，没有得到问题的解，那么我们需要回到上一层，回到上一层的做法就是把开始的修改都改回去，这就是代码的对称性。
简而言之，代码的结构就是： ***执行操作   =》 递归解决子问题  =》 问题没解决？取消之前的操作***   
***2020-10-06：*** 递归进行子问题搜寻后，无论问题是否解决，都需要将本轮递归的修改改回去，因为这只是一次尝试，不能影响同等级别的其他递归的进行。