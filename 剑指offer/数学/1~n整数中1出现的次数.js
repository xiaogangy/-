/**
 * @desc 输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如，输入12，1~12这些整数中包含1的数字有1、10、11和12，1总共出现了5次。
 *
 * solution1: 暴力求解
 * 我们可以通过判断一个数字的每一位，得知一个数字总共有多少位是1，进而我们遍历小于n的每个数字，就可以得到总共1的位数。这种解法的时间复杂度为o(nlogn)
 *
 * solution2: 找规律-凑长度为10的整数次方的区间段
 * 想象一下，如果让你找1~10000中1出现的次数，你会怎么做？我们可以知道1出现的千位、百位、十位、个位的各种情况，共有10^3 * 4 + 1种情况。为什么要说这种情况呢？
 * 因为这种特殊的数字给我们提供了思路，为啥这样的n好找总共有多少个1？因为本质上这个区间是10的整数次方，这也就为我们后面分析提供了思路，拆分成长度为10的整数次方的区间。
 *
 * 以 n = 21345为例，我们先把1~21345的所有数字分为两段：一段是1~1345，一段是1346~21345。我们先看1346~21345这个区间，刚好长度是2 * 10^4。在这个区间中，1出现
 * 的情况分为两种情况。首先分析1出现在最高位的情况。在1346~21345的数字中，1出现在10000~19999这个10000个数字的万位中，一共出现了10000次（10^4次）。
 * 注意：并不是对所有的5位数而言，1出现在万位的次数都是10000次。对于万位是1的数字，例如12345，1只出现在10000~12345的万位，这时候1出现在万位的次数等于12345-10000+1 = 2346次。
 * 接下来分析1出现在其他四个位置的情况：由于最高位是2，我们可以再把1346~21345分成两段：1346~11345和11346~21345两个区间。每一段剩下4位数字中，选择其中一位是1，其余三位可以在
 * 0~9这十个数字中任意选择，因此根据排列组合，总共出现的次数为2*4*10^3=8000次。
 * 至于1在1~1345中出现的次数，我们就可以用递归求解了。
 */

function solution(n) {
    // 为了编程方便，我们把n转换成数组
    if (n <= 0) {
        return 0;
    }
    const arr = String(n).split('').map(item => +item);
    return numbersOf1(arr);
}

/**
 * 根据传入的数组，得到1出现的次数
 * @param {*} arr 数字转换成的数组
 * @return {number} 返回1的个数
 */
function numbersOf1(arr) {
    // 健壮性无脑怼上
    if (!arr.length) {
        return 0;
    }

    const length = arr.length;
    const first = arr[0];

    // 递归出口1：传入一个个位数，而且这个个位数大于1，则1出现的次数为1
    if (length === 1 && first >= 1) {
        return 1;
    }
    // 递归出口2：传入一个个位数，而且这个个位数小于1，则1出现的次数为0
    if (length === 1 && first < 1) {
        return 0;
    }

    // 步入正题，解题过程中，还是以21345来思考
    // 1. 统计最高位出现1的次数
    let firstDigitAs1 = 0;
    if (first > 1) {
        firstDigitAs1 = Math.pow(10, length - 1);
    } else if (first === 1) {
        // 注意这里的if条件一定是first === 1，因为递归的时候，第一位有可能是等于0的
        firstDigitAs1 = +arr.join('') - Math.pow(10, length - 1) + 1;
    }

    // 2. 统计其他位1出现的次数
    // 让我们先看看高位总共能拆出来多少个10的整数次方，例如1346~21345，最高位是2，可以拆出来2个10000的区间
    // 来对应一下，first是最高位，length - 1是除了最高位还要统计其他总共几个位置，Math.pow(10, length - 2)表示其中一位为1时，其他位置可能的情况
    const numOfOtherDigits = first * (length - 1) * Math.pow(10, length - 2);

    // 3. 递归求得剩余的区间的数，比如1~1345
    arr.shift();
    const recursiveNum = numbersOf1(arr);

    return firstDigitAs1 + numOfOtherDigits + recursiveNum;
}

function testFunc() {
    const number = 101;
    console.log(solution(number));
}
testFunc();