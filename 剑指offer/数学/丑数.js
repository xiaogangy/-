/**
 * @desc 我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
 *
 * 思路：题目中提到了一个新的概念，丑数。那么给定一个数如何判断它是不是丑数呢，因为丑数只能包含2，3，5的因子，所以我们的做法就是如果这个数可以被2整除，就一直让它除以2；如果可以被
 * 3整除，就一直让它除以3，5也是同理。直到最后这三个数都不能再被整除的时候，看看结果是不是1，如果是1就说明是丑数，否则不是。
 *
 * solution1: 穷举法
 * 有了如上的思路，我们有第一种解法，那就是从0开始判断每一个数，如果是丑数，就让计数加1，直到计数器变为N。但是这种算法时间复杂度太高，因为即使一个数不是丑数，我们还是去判断了它。
 *
 * solution2: 找规律
 * 也不能说是规律，我们可以明确一点，一个丑数肯定是另外一个丑数乘以2、3、5得来的。有了这个共识，我们就好求第N个丑数了，比如我们求第1500个丑数。我们需要一个数组保存所有的丑数，而且
 * 数组中这些丑数是由小到大排列的。那么问题的关键就来了，我们如何保证数组中的丑数是有序的？如何求得下一个丑数？
 * 假设我们当前已经求得了一个丑数M，那么下一个丑数M'肯定是M前面的某个数乘以2或者3或者5得到的。暴力的办法就是我们把M之前是所有数都乘以2，然后得到一堆丑数，找到其中一个刚刚好大于M的丑数，
 * 我们记为M_2，同理可以得到M_3，M_5，这三个数中最小的那个就是M'。但是在求解的过程中，我们会进行很多无意义的计算，比如说序列中靠前的很多数，在乘以2、3、5之后其实是小于M的，这些计算就是
 * 没意义的。我们能不能追踪一个数，这个数乘以2以后刚刚好大于M，我们记这个数为T_2，同理可得T_3, T_5。这样的话，我们每次求下一个丑数M'的时候，只需要将2 * T_2、3 * T_3、5 * T_5这三个
 * 数中最小的数作为丑数就可以了。
 */

/**
 * 找第N个丑数
 * @param {*} index 第number个丑数
 * @return {number} 返回第N个丑数
 */
function getUglyNumber(index) {
    // 健壮性
    if (index <= 0) {
        return 0;
    }

    // 步入正题
    // 声明丑数序列数组(第一个丑数是1，直接写入)
    const numbers = [1];
    // T_2、T_3、T_5追踪节点
    let T2 = 0;
    let T3 = 0;
    let T5 = 0;
    // 下一个丑数
    let next = null;

    for (let i = 1; i < index; i++) {
        next = Math.min(2 * numbers[T2], 3 * numbers[T3], 5 * numbers[T5]);
        numbers.push(next);
        // 更新追踪节点
        while (2 * numbers[T2] <= next) {
            T2++;
        }
        while (3 * numbers[T3] <= next) {
            T3++;
        }
        while (5 * numbers[T5] <= next) {
            T5++;
        }
    }

    return numbers[index - 1];
}

function testFunc() {
    const n = 5;
    console.log(getUglyNumber(n));
}
testFunc();