/**
 * @desc 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印出能拼接出的所有数字中最小的一个。例如输入[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。
 *
 * solution1: 暴力求解法
 * 遇到第一眼没有好办法的题目，我们一定要先将暴力求解法告诉面试官，以展示我们的思维敏捷性。这道题，我们可以把数组中的元素进行全排列，然后比较每个得到的数字，从而得到最小值。
 *
 * solution2: 定义排序规则
 * 我们定义一种排序规则，两个数字，如果A和B，如果AB < BA，我们就说A小于B，反之，如果AB > BA，我们就说A大于B，这样的话就可以确定数组中二者的位置。经过这个排序规则对整个
 * 数组进行排序后，我们可以得到一个排序后的序列，将这个序列转成整数，就是最小的数字。但是在进行AB和BA的大小比较时，如果直接将二者转成整数，有可能溢出，所以这里会出现大数比较
 * 的问题，所以我们把拼接成的AB和BA转成字符串再进行比较。JS中字符串比较的规则是：根据第一个不同的字符的ASCII码值进行比较，其实就是字典序比较，这里AB和BA的长度一样，直接字典
 * 序比较非常可靠。
 * 具体的证明看剑指offer。
 *
 * solution3: 找规律
 * 拿题目中的例子来看，我们知道无论怎么排，最后组成的数字位数一定是一样的，所以这时候唯一能决定数值大小的就只剩下高位的元素了。要想让拼成的数值尽量下，那就让高位尽量小，所以
 * 第一步我们就是在数组中找第一位数字最小的元素，但不巧，三个数字的最高位都是3，所以我们需要再比较第二位。3没有第二位怎么办，先不管，先看看32和321这两个数字，他们的第二位都是2，
 * 这又麻烦了，还是判断不出来，这时候要判断3的位置了，因为32和321的第二位是2，都小于3，所以3如果放在这二者前面，第二位肯定要变大了，所以要把3放到最后。第三步，此时只剩下两个
 * 元素判断位置了，321的第3位是1，而32没有第三位，如果把32放在321前面，显然第三位就更大，所以要把321放在32的前面。
 * 关键点：1）要从最高位开始判断起，需要记录当前在比较第几位，即index
 * 2）确定了一个元素的值，要把它从数组中删掉，以免影响后面的比较和筛选
 * 3）如果比较到某一个位置即index时，某个元素并没有这一位，则把之前的所有位置“临时”补充到这一位后面，然后开始比较（这是因为其实在模拟这个数放在别的数前面的情况）
 * 这个方法时间复杂度比较高，虽然比较直观，但是每次需要遍历一遍数组，才能确定一个元素的位置，而且还没考虑到位数的问题，至少在O(n^2)以上
 */

function solution(arr) {
    if (!arr || !arr.length) {
        return null;
    }
    arr.sort(customSort);
    return arr.join('');
}

/**
 * 根据字典序比较两个数字，A靠前就返回-1，靠后就返回1，相等就返回0
 * @param {*} a 待比较数字
 * @param {*} b 待比较数字
 * @return {number} -1|1|0，分别表示小于|大于|等于
 */
function customSort(a, b) {
    const AB = a + '' + b;
    const BA = b + '' + a;
    if (AB === BA) {
        return 0;
    }
    return AB < BA ? -1 : 1;
    // // 比较字符串的字典序，推荐使用如下方法，但是不知道为啥这个方法牛客上总是说堆栈溢出，还是先用上面的吧
    // return AB.localeCompare(BA);
}

function testFunc() {
    // const array = [3, 321, 32];
    const array = [789, 123, 3, 4];
    console.log(solution(array));
}
testFunc();