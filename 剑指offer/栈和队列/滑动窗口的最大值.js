/**
 * @desc 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；
 * 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
 *
 * solution1: 暴力求解
 * 最简单最直观的方法，就是每次滑动窗口，然后在窗口中找到最大值。如果窗口大小为k，数组长度为n，则时间复杂度为O(nk);
 *
 * solution2: 保存最大值的队列
 * 设想一下，假如我们有一个数据结构，其中保存当前滑动窗口中的最大值。滑动窗口中每进入一个值，我们就和之前的最大值比较，如果不如原来的最大值大，就输出原来的最大值，但是要把这个新值放入数据结构中，
 * 因为它可能是后续滑动窗口的最大值；如果比原来的最大值大呢？把原来数据结构中的最大值弹出，然后把当前值作为新的最大值。这只是一个粗略的思路，但是我们可以看出双向队列可以担当这个数据结构的重任，
 * 如果对之前min栈那个算法题非常熟悉，会发现这里的思路和实现一个O(1)时间复杂度的max队列基本一致，下面我们来结合数组[2,3,4,2,6,2,5,1]讨论一些细节：
 * - 首先初始化滑动窗口，也就是将第一个滑动窗口的数据填充满。在填充滑动窗口的过程中，数据也要依次进入max队列，如果后进的数字比之前的数字大，就把之前的数字都弹出。
 * 比如第一个滑动窗口是{2, 3, 4}, max队列中最后只剩下[4]，即最大值位于队列的头部
 * - 然后滑动窗口开始移动，此时新的值2进入滑动窗口，但是此时2小于max队列中的最大值，我们仍要把它放入max中，因为等max头元素弹出后，它有可能是滑动窗口的最大值，此时
 * max为[4, 2]
 * - 继续重复移动滑动窗口，6进入滑动窗口，此时滑动窗口元素为{4, 2, 6}，6大于max中的前面的所有元素，所以把前面的元素都弹出，max变为[6]
 * - 之后的滑动窗口为{2, 6, 2}, max为[6, 2]; {6, 2, 5}, max为[6, 5]；
 * - 当1进入滑动窗口时，滑动窗口变为{2, 5, 1}，虽然1进入了max，但是此时由于6离开了滑动窗口，当然也要离开max队列，所以此时的max变为[5, 1];
 * 我们看到，上面的模拟过程中有两个特别要注意的点：
 * 什么时候max最大值弹出？
 * 1. 当新进入的值大于当前max的最大值时，原先的max弹出；
 * 2. 当max映射到的值不在滑动窗口中时，原先的max要弹出
 * 为了维持2中的映射关系，我们将最大数值的索引存入max中，而不是存入最大值，这样当滑动窗口新进入元素的索引 newIndex - maxIndex(max中最大元素的索引) = 滑动窗口size时，
 * 要弹出max队列中当前的最大值，因为这个最大值已经不在滑动窗口中了
 *
 * ……这绝对是我写过的最长的解释，真他娘的乱，其实很简单，就是用两个队列实现一个新的队列，要保证这个新队列中getMax的时间复杂度为O(1)……
 */

function maxInWindows(num, size) {
    // 健壮性判断：数组为空 | 滑动窗口size小于1 | 滑动窗口大小大于数组长度
    if (!num.length || size < 1 || size > num.length) {
        return [];
    }

    // 步入正题
    const result = [];
    // 1. 声明是max队列，不需要滑动窗口队列是因为它在这里确实没啥用，我们遍历num就可以了
    const maxQueue = [];

    // 2. 初始化滑动窗口
    for (let i = 0; i < size; i++) {
        const value = num[i];
        // 数据取最大值进入max队列
        while (maxQueue.length && value > num[maxQueue[maxQueue.length - 1]]) {
            maxQueue.pop();
        }
        // 注意：这里压入的是max的索引
        maxQueue.push(i);
    }
    // 先把当前maxQueue中的最大值保存到result中
    result.push(num[maxQueue[0]]);

    // 3. 开始移动滑动窗口
    for (let i = size; i < num.length; i++) {
        // 判断新进入的元素和当前maxQueue队尾的元素
        const value = num[i];
        // 3.1) 先判断当前maxQueue中的最大值是不是已经从滑动窗口中出去了
        if (i - maxQueue[0] >= size) {
            maxQueue.shift();
        }
        // 3.2) 再判断新进入的元素应该添加到maxQueue中的哪个位置
        while (maxQueue.length && value > num[maxQueue[maxQueue.length - 1]]) {
            maxQueue.pop();
        }
        maxQueue.push(i);
        // 3.3) 不要忘记把max值放到result中
        result.push(num[maxQueue[0]]);
    }

    return result;
}

function testFunc() {
    const numbers = [2, 3, 4, 2, 6, 2, 5, 1];
    const size = 3;
    console.log(maxInWindows(numbers, size));
}
testFunc();
