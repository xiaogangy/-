/**
 * @desc 给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？
 * 例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。
 *
 * solution：我们之前用动态规划的方法解决了该问题，DP解法的时间复杂度为O(n^2)，空间复杂度为O(n)，这里用贪心来解决的时候，只需要O(1)的时间和空间复杂度。
 * 我们先说使用贪心每一步选择的贪心策略，后面再证明：
 * - 当n >= 5时，我们尽可能多地剪长度为3的绳子；
 * - 当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子
 *
 * 时间复杂度，空间复杂度：O(1)
 */

function maxProductAfterCutting(number) {
    if (number < 2) {
        return 0;
    }
    if (number === 2) {
        return 1;
    }
    if (number === 3) {
        return 2;
    }

    // 尽可能多的剪去长度为3的绳子段
    let timesOf3 = Math.floor(number / 3);

    // 当绳子最后剩下的长度为4时，不能再剪去长度为3的绳子段。此时最好的办法是把绳子剪成长度为2的两段，因为2*2 > 3*1
    if (timesOf3 * 3 + 1 === number) {
        timesOf3 = timesOf3 - 1;
    }

    let timesOf2 = Math.floor((number - timesOf3 * 3) / 2);

    const result = Math.pow(3, timesOf3) * Math.pow(2, timesOf2);
    return result;
}

/**
 * 使用贪心策略解决完问题之后，要能够证明每次采用局部最优解之后能够得到全局最优解。在这个题目中
 * 1、当n >= 5时，我们可以证明 2*(n-2) > n，同样的，3*(n-3) > n，这个不等式意思是，用2或者用3去拆分，都会使乘积变大。同时，当n >= 5时，3*(n-3) > 2*(n-2)，所以当绳子长度大于5时我们要尽量减长度为3的绳子段。
 * 2、当绳子长度为4呢？在长度为4的绳子上剪一刀，有两种可能的结果，[1, 3]和[2, 2]，显然2*2 > 3*1，也就是说当绳子长度为4时，要剪成2*2的子段
 */