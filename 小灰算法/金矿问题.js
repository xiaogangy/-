/**
 * @description 某地有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数量也不同。例如有的金矿储量是500Kg黄金，需要5个工人来挖掘；有的金矿的储量是200kg黄金，需要3个工人来挖掘……
 * 现有5个金矿，10名挖掘工人，挖掘每个金矿所需要的人数如下：
 * 金矿1： 价值200kg, 需要3人
 * 金矿2： 价值300kg, 需要4人
 * 金矿3： 价值350kg, 需要3人
 * 金矿4： 价值400kg, 需要5人
 * 金矿5： 价值500kg, 需要5人
 * 每个金矿要么全挖，要么不挖，那么要想获得尽可能多的黄金，应该如何选择挖哪几个金矿？
 *
 * 思路：这道题和0-1背包问题如出一辙，是一道动态规划的题目，那么什么是动态规划呢？
 * 动态规划是一种分治思想，即把复杂的问题简化成为规模较小的子问题，再从简单的子问题自底向上一步步地推，最终得到复杂问题的最优解。动态规划是解决重叠子问题的一种方法。
 * 那么对于这道题的分析可以如下进行：
 * 每座金矿存在两种情况，要么挖，要么不挖，例如以第5座金矿为例，可以选择挖或者不挖，如果挖的话，那么人力变为5人，这剩下的5人要在剩余的4座金矿中做出选择；或者不挖，即10人在4座金矿做出选择；
 * 问题就变为这两种情况下，找到可以产生的最大收益，这种情况就被称为全局问题的两个最优子结构。继续分治的话，每种情况又可以分为，要不要挖第四座矿，持续划分，直到简化为0个工人或者0座金矿可供选择的情况，
 * 这个时候的收益显然为0，我们把这种终止情况称为边界。
 *
 * 动态规划的要点：
 * 1. 确定全局最优解和最优子结构之间的关系
 * 2. 确定问题的边界
 * 上面2个要点，我们可以称之为状态转移方程
 *
 * 解法：对应在本题，我们可以做如下分析
 * 假设金矿数量为n，工人数量为w，金矿的含金量为g[]，每座金矿需要的开采人员数量为p[]，F(n, w)表示w个工人开采n个金矿可达到的最大收益。可得到的状态转移方程如下：
 * F(n, w) = 0(n=0或者w=0)
 * F(n, w) = F(n-1, w)(当w < p[n-1]，即当前工人数量不足以开采第n座矿，那么子结构就只有一种情况，就是不开采当前这座矿)
 * F(n, w) = max(F(n-1, w), F(n-1, w-p[n-1]) + g[n-1])(n>=1, w>=p[n-1]，即常规情况下的两种最优子结构)
 */


/**
 * 解法一： 根据如上方程，很容易写出递归的解法
 * @param {*} n 金矿数量
 * @param {*} w 工人数量
 * @param {*} g 金矿的含金量
 * @param {*} p 每座金矿的开采人员数量
 * @return {number} 最大的黄金数
 */
function getBestGoldMining(n, w, g, p) {
    // 递归先写终止条件
    // 1. 第一种状态转移方程
    if (w === 0 || n === 0) {
        return 0;
    }
    // 2. 第二种状态转移方程
    if (w < p[n - 1]) {
        return getBestGoldMining(n - 1, w, g, p);
    }
    // 3. 常规状态转移方程
    const sub1 = getBestGoldMining(n - 1, w, g, p); // 不挖第n个矿
    const sub2 = getBestGoldMining(n - 1, w - p[n - 1], g, p) + g[n - 1]; // 挖第n个矿
    return Math.max(sub1, sub2);
}

/**
 * 解法二： 上面递归的方法会出现重复计算，根据递归树来看，5座金矿就会进行2^5计算，计算量为O(n^2)，时间复杂度太高了，那么如何保存这些计算过的值呢？
 * 我们可以列一个二维矩阵，矩阵的纵轴示第几个矿，横轴表示工人的数量，表格如下：
 * ------------------------------------------------------------------------------------
 * |            |1个工人|2个工人|3个工人|4个工人|5个工人|6个工人|7个工人|8个工人|9个工人|10个工人|
 * |400kg黄金/5人|      |      |      |      |      |      |      |      |      |      |
 * |500kg黄金/5人|      |      |      |      |      |      |      |      |      |      |
 * |200kg黄金/3人|      |      |      |      |      |      |      |      |      |      |
 * |300kg黄金/4人|      |      |      |      |      |      |      |      |      |      |
 * |350kg黄金/3人|      |      |      |      |      |      |      |      |      |      |
 * ------------------------------------------------------------------------------------
 * 表格中的每一个空格，以第四行，第九列的空格为例，表示在有9个工人、可供选择矿有4种情况下的最优选择，即F(4, 9)。我们可以从第一列开始算起，
 * 前4个空格，因为工人数都小于开采当前矿所需要的工人数量，所以收益都为0，后面的值，可以用上面的状态转移方程计算得到。我们一直做类似的计算，直到得到最后一个空格，
 * 即F(5, 10)的值，这就是最终的收益。
 *
 * 时间复杂度，空间复杂度： O(n * w)
 *
 * @param {*} n 金矿数量
 * @param {*} w 工人数量
 * @param {*} g 金矿的含金量
 * @param {*} p 每座金矿的开采人员数量
 * @return {number} 最大的黄金数
 */
function getBestGoldMining_Opt(n, w, g, p) {
    // 先声明结果表格，是一个二维数组
    const result = new Array(n + 1).fill(0).map(item => new Array(w + 1).fill(0)); // 声明多一行，用来保证索引直接从1开始
    // 使用一个双层循环来填写表格
    for (let i = 1; i < n + 1; i++) {
        for (let j = 1; j < w + 1; j++) {
            // 当前工人数量不够完成当前金矿数目
            if (j < p[i - 1]) {
                result[i][j] = result[i - 1][j];
            } else {
                result[i][j] = Math.max(result[i - 1][j], result[i - 1][j - p[i - 1]] + g[i - 1]);
            }
        }
    }
    // 返回最后一个格子的内容
    return result[n][w];
}

/**
 * 解法三：以上的方法是声明一个二维数组，然后依次进行填充，空间复杂度为O(n * w);
 * 但是事实上，并不需要使用一个完整的二维数组，以上的计算我们会发现，我们计算一行的时候，只会用到上一行的值，
 * 因此，我们可以声明一个一维数组，用来保存上一行的数据，然后每次写入新一行数据的时候，从右往左覆盖旧的数据。
 * 为什么要从右往左呢？因为在状态转移方程中result[i - 1][j - p[i - 1]] + g[i - 1]这一项中，我们要用到上一行的旧值
 * 这样的话，时间复杂度可以降低到O(w)；
 *
 * @param {*} n 金矿数量
 * @param {*} w 工人数量
 * @param {*} g 金矿的含金量
 * @param {*} p 每座金矿的开采人员数量
 * @return {number} 最大的黄金数
 */
function getBestGoldMining_final(n, w, g, p) {
    // 创建当前结果
    const result = new Array(w + 1).fill(0);
    for (let i = 1; i < n + 1; i++) {
        for (let j = w; j > 0; j--) {
            // 这里会发现只判断了一种情况，这是因为当不满足该条件时，即当前工人数量不足以开采当前矿，则收益等于result[j] = result[j]，不变
            if (j >= p[i - 1]) {
                // result = max(不选，选)
                result[j] = Math.max(result[j], result[j - p[i - 1]] + g[i - 1]);
            }
        }
    }
    return result[w];
}

function testFunc() {
    let w = 10;
    let g = [400, 500, 200, 300, 350];
    let p = [5, 5, 3, 4, 3];
    console.log('最佳收益为', getBestGoldMining_Opt(g.length, w, g, p));
    console.log('最佳收益为', getBestGoldMining_final(g.length, w, g, p));
}

testFunc();